import{_ as l,v as i,b as a,R as o}from"./chunks/framework.caa0fbaf.js";const p=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"markdown/云生态/常见问答与分享/article-son/分享分布式系统设计小指导.md","filePath":"markdown/云生态/常见问答与分享/article-son/分享分布式系统设计小指导.md"}'),e={name:"markdown/云生态/常见问答与分享/article-son/分享分布式系统设计小指导.md"},r=o('<p>对新手同学来讲，确实也算是份思想指导。另外，各处场景有 Solon Cloud 接口使用注释，方便关联使用。</p><h3 id="_1、构建可水平扩展的计算能力" tabindex="-1">1、构建可水平扩展的计算能力 <a class="header-anchor" href="#_1、构建可水平扩展的计算能力" aria-label="Permalink to &quot;1、构建可水平扩展的计算能力&quot;">​</a></h3><h5 id="a-服务去状态化" tabindex="-1">a) 服务去状态化 <a class="header-anchor" href="#a-服务去状态化" aria-label="Permalink to &quot;a) 服务去状态化&quot;">​</a></h5><ul><li>不要本地存东西 <ul><li>如日志、图片（当多实例部署时，不知道去哪查或哪取?）</li><li>//可以使用 Solon Cloud File、Solon Cloud Log 和相关的中间件</li></ul></li><li>不要使用本地的东西 <ul><li>如本地配置（当多实例部署时，需要到处修改、或者重新部署！运维都不知道开发配了什么）</li><li>//可以使用 Solon Cloud Config 和相关的中间件</li></ul></li></ul><h5 id="b-服务透明化" tabindex="-1">b) 服务透明化 <a class="header-anchor" href="#b-服务透明化" aria-label="Permalink to &quot;b) 服务透明化&quot;">​</a></h5><ul><li>建立配置服务体系 <ul><li>在一个地方任何人可见</li><li>修改后，即时热更新到服务实例或者重启即可</li><li>包括应用配置、国际化配置等...</li><li>//可以使用 Solon Cloud Config、Solon Cloud I18n 和相关的中间件</li></ul></li><li>建立链路日志服务体系 <ul><li>让所有日志集中在一处，并任何人方便可查</li><li>让输出输出的上下文成为日志的一部份，出错时方便排查</li><li>//可以使用 Solon Cloud Trace、Solon Cloud Log 和相关的中间件</li></ul></li><li>建立跟踪、监控与告警服务体系 <ul><li>哪里出错，能马上知道</li><li>哪里数据异常，能马上知道</li><li>哪里响应时间太慢，马上能知道</li><li>//可以使用 Solon Cloud Trace、Solon Cloud Metric 和相关的中间件</li></ul></li></ul><blockquote><p>完成这2点，分布式和集群会比较友好。</p></blockquote><h5 id="c-容器化弹性伸缩" tabindex="-1">c) 容器化弹性伸缩 <a class="header-anchor" href="#c-容器化弹性伸缩" aria-label="Permalink to &quot;c) 容器化弹性伸缩&quot;">​</a></h5><ul><li>建立在k8s环境之上，集群虚拟化掉，会带来很大的方便</li></ul><h3 id="_2、构建可水平扩展的业务能力" tabindex="-1">2、构建可水平扩展的业务能力 <a class="header-anchor" href="#_2、构建可水平扩展的业务能力" aria-label="Permalink to &quot;2、构建可水平扩展的业务能力&quot;">​</a></h3><p>//可以使用 Solon Cloud Event 和相关的中间件</p><h5 id="a-基于可独立领域的业务与数据拆分" tabindex="-1">a) 基于可独立领域的业务与数据拆分 <a class="header-anchor" href="#a-基于可独立领域的业务与数据拆分" aria-label="Permalink to &quot;a) 基于可独立领域的业务与数据拆分&quot;">​</a></h5><p>比如把一个电商系统拆为：</p><ul><li>用户领域系统</li><li>订单领域系统</li><li>支付领域系统</li></ul><p>各自独立数据，独立业务服务。故而，每次一块业务，都不响应旧的业务。进而水平扩展</p><h5 id="b-拆分业务的主线与辅线" tabindex="-1">b) 拆分业务的主线与辅线 <a class="header-anchor" href="#b-拆分业务的主线与辅线" aria-label="Permalink to &quot;b) 拆分业务的主线与辅线&quot;">​</a></h5><p>比如用户注册行为：</p><ul><li>用户信息保存 [主线]</li><li>注册送红包 [辅线]</li><li>检查如果有10个人的通讯录里有他的手机号，再送红包[辅线]</li><li>因为与电信合作，注册后调用电信接口送100元话费[辅线]</li></ul><h5 id="c-基于分布式事件总线交互" tabindex="-1">c) 基于分布式事件总线交互 <a class="header-anchor" href="#c-基于分布式事件总线交互" aria-label="Permalink to &quot;c) 基于分布式事件总线交互&quot;">​</a></h5><ul><li><p>由独立领域发事件，其它独立领域订阅事件</p><ul><li>比如用户订单系统与公司财务系统：</li><li>订单支付完成后，发起事件；公司财务系统可以订阅，然后处理自己的财务需求</li></ul></li><li><p>由主线发起事件，辅线进行订阅。可以不断扩展辅线，而不影响原有代码</p><ul><li>这样的设计，即可以减少请求响应时间；又可以不断水平扩展业务</li></ul></li></ul>',20),t=[r];function n(u,d,h,c,s,_){return i(),a("div",null,t)}const m=l(e,[["render",n]]);export{p as __pageData,m as default};
