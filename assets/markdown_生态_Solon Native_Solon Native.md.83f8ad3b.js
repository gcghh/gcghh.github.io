import{_ as a,v as t,b as e,R as o}from"./chunks/framework.caa0fbaf.js";const v=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"markdown/生态/Solon Native/Solon Native.md","filePath":"markdown/生态/Solon Native/Solon Native.md"}'),l={name:"markdown/生态/Solon Native/Solon Native.md"},r=o('<p>Solon Native 是可以让 Solon 应用程序以 GraalVM 原生镜像的方式运行的技术方案。</p><h4 id="技术组成" tabindex="-1">技术组成： <a class="header-anchor" href="#技术组成" aria-label="Permalink to &quot;技术组成：&quot;">​</a></h4><table><thead><tr><th>插件</th><th>说明</th></tr></thead><tbody><tr><td>solon.aot</td><td>为AOT处理提供支持</td></tr><tr><td>solon-maven-plugin:process-aot</td><td>为AOT打包提供支持（自动生成元信息配置）</td></tr></tbody></table><h4 id="简单的原理" tabindex="-1">简单的原理： <a class="header-anchor" href="#简单的原理" aria-label="Permalink to &quot;简单的原理：&quot;">​</a></h4><p>容器型的框架，要支持 Graalvm 原生打包。主要有三方面的麻烦：</p><ul><li>不能有动态编译或者字节码构建</li><li>不能有反射，或者通过配置申明反射相关信息</li><li>所有资源要配置申明</li></ul><p>想要 Ioc/Aop，对类的动态代理就逃不了；对反射的需求也逃不了；还有 Spi 配置，应用自身的资源等。幸好 Solon 是一个提倡“克制”的容器型框架。</p><p>这种“克制”是 Solon 更简单的通过 AOT 技术解决麻烦的基础。</p><h4 id="用于演示原生编译的项目" tabindex="-1">用于演示原生编译的项目： <a class="header-anchor" href="#用于演示原生编译的项目" aria-label="Permalink to &quot;用于演示原生编译的项目：&quot;">​</a></h4><ul><li><a href="https://gitee.com/noear/solon-native-example" target="_blank" rel="noreferrer">https://gitee.com/noear/solon-native-example</a></li></ul><h4 id="开发学习" tabindex="-1">开发学习： <a class="header-anchor" href="#开发学习" aria-label="Permalink to &quot;开发学习：&quot;">​</a></h4><ul><li><a href="/article/505.html">学习 / Solon Native 开发</a></li></ul>',12),n=[r];function i(s,d,h,c,p,m){return t(),e("div",null,n)}const _=a(l,[["render",i]]);export{v as __pageData,_ as default};
