import{_ as a,v as s,b as t,R as e}from"./chunks/framework.caa0fbaf.js";const _=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"markdown/学习/Solon 开发之配置/article-son/八、更好的配置 server 线程数.md","filePath":"markdown/学习/Solon 开发之配置/article-son/八、更好的配置 server 线程数.md"}'),r={name:"markdown/学习/Solon 开发之配置/article-son/八、更好的配置 server 线程数.md"},l=e(`<p>以 http server 为例，讨论下 server 的几个线程数配置：</p><div class="language-yml"><button title="Copy Code" class="copy"></button><span class="lang">yml</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">#服务 http 最小线程数（默认：0表示自动，支持固定值 2 或 内核倍数 x2）//一般不用配置</span></span>
<span class="line"><span style="color:#F07178;">server.http.coreThreads</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#A6ACCD;"> </span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">#服务 http 最大线程数（默认：0表示自动，支持固定值 32 或 内核倍数 x32） </span></span>
<span class="line"><span style="color:#F07178;">server.http.maxThreads</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">#服务 http 闲置线程超时（0表示自动，单位毫秒） //v1.10.13 后支持</span></span>
<span class="line"><span style="color:#F07178;">server.http.idleTimeout</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">#服务 http 是否为IO密集型？ //v1.12.2 后支持</span></span>
<span class="line"><span style="color:#F07178;">server.http.ioBound</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FF9CAC;">true</span></span></code></pre></div><p>线程，不是越多越好（切换需要费时间），也不是越少越好（会不够用）。了解情况，作合适的配置为佳。</p><h3 id="_1、两个重要概念" tabindex="-1">1、两个重要概念 <a class="header-anchor" href="#_1、两个重要概念" aria-label="Permalink to &quot;1、两个重要概念&quot;">​</a></h3><ul><li>Cpu 密集型</li></ul><p>比如写一个 “hello world” 程序，不做任何处理直接返回字符串。它就算是 cpu 密集型了。事情只在内存与cpu里完成了。</p><p>这种情况，一般响应非常快。如果线程多了，切换线程的时间反而成了一种性能浪费。</p><ul><li>Io 密集型</li></ul><p>比如写 crud 的程序，一个数据保存到数据库里；或者上传文件，保存到磁盘里。事情“额外”涉及了网卡、磁盘等一些Io处理。</p><p>这种情况，一般响应会慢，有些可能还要10多秒。一次处理会占用一个线程，线程往往会不够用。</p><h3 id="_2、框架默认的配置" tabindex="-1">2、框架默认的配置 <a class="header-anchor" href="#_2、框架默认的配置" aria-label="Permalink to &quot;2、框架默认的配置&quot;">​</a></h3><p>当 <code>server.http.ioBound: true</code> 时：</p><table><thead><tr><th></th><th>线程数</th><th>例：2c4g 的线程数</th></tr></thead><tbody><tr><td>coreThreads</td><td>内核数的 2倍（一般是不用配置的）</td><td>4</td></tr><tr><td>maxThreads</td><td>coreThreads 的32倍</td><td>128</td></tr></tbody></table><p>当 <code>server.http.ioBound: false</code> 时：</p><table><thead><tr><th></th><th>线程数</th><th>例：2c4g 的线程数</th></tr></thead><tbody><tr><td>coreThreads</td><td>内核数的 2倍（一般是不用配置的）</td><td>4</td></tr><tr><td>maxThreads</td><td>coreThreads 的8倍</td><td>32</td></tr></tbody></table><h3 id="_3、如何做简单的计算" tabindex="-1">3、如何做简单的计算 <a class="header-anchor" href="#_3、如何做简单的计算" aria-label="Permalink to &quot;3、如何做简单的计算&quot;">​</a></h3><ul><li>关于 qps</li></ul><p>比如一次请求响应为 0.1 秒，那一个线程1秒内可以做10次响应，100个线程，可以做1000个响应。即 qps = 1000</p><ul><li>关于内存</li></ul><p>一个线程最少会占用 1m - 2m的内存。100个线程，就算是 200m</p><p>一个请求包，如果是 200k，操作处理时可能会有多个副本（算它4个），那是 800k。qps 1000 时，每秒占用 800m/s 的内存，如果5s后才自动释放，那实际每秒占用为 4g/s</p><h3 id="_4、为什么-corethreads-不需要配置" tabindex="-1">4、为什么 coreThreads 不需要配置 <a class="header-anchor" href="#_4、为什么-corethreads-不需要配置" aria-label="Permalink to &quot;4、为什么 coreThreads 不需要配置&quot;">​</a></h3><ul><li><p>对 bio 来说，coreThreads 太大，就不会收缩了。</p></li><li><p>对 nio 来说，coreThreads 不能太大。nio 与 bio 一般做两段式线程池，coreThreads 即为它的第一段，maxThreads 则为第二段。</p></li></ul><h3 id="_5、线程-即-maxthreads-不够时一般会怎么样" tabindex="-1">5、线程（即 maxThreads）不够时一般会怎么样 <a class="header-anchor" href="#_5、线程-即-maxthreads-不够时一般会怎么样" aria-label="Permalink to &quot;5、线程（即 maxThreads）不够时一般会怎么样&quot;">​</a></h3><ul><li>可能会卡，但卡一会儿还能接收请求</li></ul><p>这种情况，一般是提交线程池被拒后，改用主线程处理。所以主线程没法再接收请求了，需要等手上的活完成后才能再接收请求。</p><ul><li>直接是返回异常或者当前关闭链接（即拒绝服务）</li></ul><p>通过协议直接返回异常，是为了让客户端马上知道结果，服务端吃不消了。如果直接关闭链接了，那是解析协议的线程也不够用了，没法按协议返回，就直接关链接了。</p><h3 id="_6、如何配置-maxthreads" tabindex="-1">6、如何配置 maxThreads <a class="header-anchor" href="#_6、如何配置-maxthreads" aria-label="Permalink to &quot;6、如何配置 maxThreads&quot;">​</a></h3><p>一般默认即可。如果是单实例，流量大或请求慢。可以根据内存，把 maxThreads 配大些，比如这个服务能用1c2g标准的：</p><p>如果可以配成：x256 。即 512 个线程，每个线程按2m占用算，线程最大内存占用为 1024g。还有 1g 用于业务数据处理。可能有点吃紧，也可能内存会暴掉。</p>`,31),o=[l];function n(p,d,h,c,i,u){return s(),t("div",null,o)}const y=a(r,[["render",n]]);export{_ as __pageData,y as default};
