import{_ as t,v as a,b as s,R as e}from"./chunks/framework.caa0fbaf.js";const b=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"markdown/学习/Solon Data 开发/article-son/一、事务的传播机制.md","filePath":"markdown/学习/Solon Data 开发/article-son/一、事务的传播机制.md"}'),d={name:"markdown/学习/Solon Data 开发/article-son/一、事务的传播机制.md"},r=e('<p>Solon 的事务传播机制，与 Spring 的几乎一致。</p><h3 id="_1、事务为什么要有传播机制" tabindex="-1">1、事务为什么要有传播机制？ <a class="header-anchor" href="#_1、事务为什么要有传播机制" aria-label="Permalink to &quot;1、事务为什么要有传播机制？&quot;">​</a></h3><p>几个场景的探讨：</p><ul><li>场景一：classA 方法调用了 classB 方法，但两个方法都有事务</li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">如果 classB 方法异常，是让 classB 方法提交，还是两个一起回滚？</span></span></code></pre></div><ul><li>场景二：classA 方法调用了 classB 方法，但是只有 classA 方法加了事务</li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">是否把 classB 也加入 classA 的事务，如果 classB 异常，是否回滚 classA？</span></span></code></pre></div><ul><li>场景三：classA 方法调用了 classB 方法，两者都有事务，classB 已经正常执行完，但 classA 异常</li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">是否需要回滚 classB 的数据？</span></span></code></pre></div><p>这个时候，传说中的事务传播机制和策略就派上用场了</p><h3 id="_2、传播机制生效条件" tabindex="-1">2、传播机制生效条件 <a class="header-anchor" href="#_2、传播机制生效条件" aria-label="Permalink to &quot;2、传播机制生效条件&quot;">​</a></h3><p>所有用 aop 实现的事务控制方案 ，都是针对于接口或类的。所以在同一个类中两个方法的调用，传播机制是不生效的。知晓这一点很重要！</p><h3 id="_3、传播机制的策略" tabindex="-1">3、传播机制的策略 <a class="header-anchor" href="#_3、传播机制的策略" aria-label="Permalink to &quot;3、传播机制的策略&quot;">​</a></h3><p>下面的类型都是针对于被调用方法来说的，理解起来要想象成两个 class 方法的调用才可以。</p><table><thead><tr><th>传番策略</th><th>说明</th></tr></thead><tbody><tr><td>TranPolicy.required</td><td>支持当前事务，如果没有则创建一个新的。这是最常见的选择。也是默认。</td></tr><tr><td>TranPolicy.requires_new</td><td>新建事务，如果当前存在事务，把当前事务挂起。</td></tr><tr><td>TranPolicy.nested</td><td>如果当前有事务，则在当前事务内部嵌套一个事务；否则新建事务。</td></tr><tr><td>TranPolicy.mandatory</td><td>支持当前事务，如果没有事务则报错。</td></tr><tr><td>TranPolicy.supports</td><td>支持当前事务，如果没有则不使用事务。</td></tr><tr><td>TranPolicy.not_supported</td><td>以无事务的方式执行，如果当前有事务则将其挂起。</td></tr><tr><td>TranPolicy.never</td><td>以无事务的方式执行，如果当前有事务则报错。</td></tr></tbody></table><h3 id="_4、事务的隔离级别" tabindex="-1">4、事务的隔离级别 <a class="header-anchor" href="#_4、事务的隔离级别" aria-label="Permalink to &quot;4、事务的隔离级别&quot;">​</a></h3><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>unspecified</td><td>默认（JDBC默认）</td></tr><tr><td>read_uncommitted</td><td>脏读：其它事务，可读取未提交数据</td></tr><tr><td>read_committed</td><td>只读取提交数据：其它事务，只能读取已提交数据</td></tr><tr><td>repeatable_read</td><td>可重复读：保证在同一个事务中多次读取同样数据的结果是一样的</td></tr><tr><td>serializable</td><td>可串行化读：要求事务串行化执行，事务只能一个接着一个执行，不能并发执行</td></tr></tbody></table><h3 id="_5、-tran-属性说明" tabindex="-1">5、@Tran 属性说明 <a class="header-anchor" href="#_5、-tran-属性说明" aria-label="Permalink to &quot;5、@Tran 属性说明&quot;">​</a></h3><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>policy</td><td>事务传导策略</td></tr><tr><td>isolation</td><td>事务隔离等级</td></tr><tr><td>readOnly</td><td>是否为只读事务</td></tr></tbody></table>',19),l=[r];function o(n,i,c,p,h,_){return a(),s("div",null,l)}const m=t(d,[["render",o]]);export{b as __pageData,m as default};
