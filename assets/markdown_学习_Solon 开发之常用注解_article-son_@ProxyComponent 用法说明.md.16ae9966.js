import{_ as s,v as n,b as a,R as l}from"./chunks/framework.caa0fbaf.js";const A=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"markdown/学习/Solon 开发之常用注解/article-son/@ProxyComponent 用法说明.md","filePath":"markdown/学习/Solon 开发之常用注解/article-son/@ProxyComponent 用法说明.md"}'),o={name:"markdown/学习/Solon 开发之常用注解/article-son/@ProxyComponent 用法说明.md"},p=l(`<p>在 Solon 提倡“克制”的原则下，托管组件分为：</p><ul><li>普通组件</li><li>代理组件（即 @ProxyComponent 注解的类）。代理的细节可以看下<a href="/article/442.html">《动态代理的本质》</a> 。</li></ul><p>之所以需要代理，是为了能拦截函数；之所以需要拦截函数，是为了让函数上的注解生效。也算是 AOP 的基础。<mark>（如果没有拦截需求，改用 @Component）</mark></p><p>如何使用 @ProxyComponent 注解？</p><h3 id="_1、从替代的角度、或语义的角度使用" tabindex="-1">1、从替代的角度、或语义的角度使用 <a class="header-anchor" href="#_1、从替代的角度、或语义的角度使用" aria-label="Permalink to &quot;1、从替代的角度、或语义的角度使用&quot;">​</a></h3><p>原来使用 <mark>@Service、@Dao、@Repository</mark> 这三个注解的，或者有这三种语义的类，都用 “@ProxyComponent” 注解。这些类经常会用到事务、或者缓存注解，就会需要函数拦截。使用示例：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">ProxyComponent</span></span>
<span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">UserService</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">//...</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">ProxyComponent</span></span>
<span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">UserDao</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">//...</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">ProxyComponent</span></span>
<span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">UserRepository</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">//...</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>从团队执行规范的管理角度，这个方式比较好，简单：语义对上，就用。</p><h3 id="_2、从技术的角度使用" tabindex="-1">2、从技术的角度使用 <a class="header-anchor" href="#_2、从技术的角度使用" aria-label="Permalink to &quot;2、从技术的角度使用&quot;">​</a></h3><p>如果一个类的函数上，使用了“用于拦截的注解”，则使用 “@ProxyComponent” ；如果没有，则使用 “@Component”。比如：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">//这个类，虽然也叫 Service，但是函数没有使用“用于拦截的注解”就使用普通组件注解即可。</span></span>
<span class="line"><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">Component</span></span>
<span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">ToolService</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> bool </span><span style="color:#82AAFF;">isEmpty</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">str</span><span style="color:#89DDFF;">){</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> str</span><span style="color:#89DDFF;">=null</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">||</span><span style="color:#A6ACCD;"> str</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">length</span><span style="color:#89DDFF;">()==</span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">//这个类，使用了“用于拦截的注解”，需要使用 &quot;@ProxyComponent&quot;（在函数上加注解，基本上都是拦截目的）</span></span>
<span class="line"><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">ProxyComponent</span></span>
<span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">UserService</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">Tran</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">addUser</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">UserDo</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">user</span><span style="color:#89DDFF;">){</span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">//...</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>从高性能与克制角度，这个方式好。但团队的话，因人员素质差异，可能不好把控细节。</p><h3 id="_3、补充" tabindex="-1">3、补充 <a class="header-anchor" href="#_3、补充" aria-label="Permalink to &quot;3、补充&quot;">​</a></h3><p>为什么 “@Controller、@Remoting” 不是动态代理类，也支持函数拦截？因为它们的 Method 被提取并包装成了 MethodWrap。而，所有的函数拦截最终都是由 MethodWrap 执行。</p>`,14),e=[p];function t(c,r,y,i,C,D){return n(),a("div",null,e)}const m=s(o,[["render",t]]);export{A as __pageData,m as default};
