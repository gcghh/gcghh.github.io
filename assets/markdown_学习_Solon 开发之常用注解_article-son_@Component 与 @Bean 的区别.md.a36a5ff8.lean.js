import{_ as n,v as o,b as e,R as a}from"./chunks/framework.caa0fbaf.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"markdown/学习/Solon 开发之常用注解/article-son/@Component 与 @Bean 的区别.md","filePath":"markdown/学习/Solon 开发之常用注解/article-son/@Component 与 @Bean 的区别.md"}'),t={name:"markdown/学习/Solon 开发之常用注解/article-son/@Component 与 @Bean 的区别.md"},i=a('<p>@Component 与 @Bean 设计的目的是一样的，都是注册 Bean 到容器里。</p><h3 id="_1、-component-注解" tabindex="-1">1、@Component 注解 <a class="header-anchor" href="#_1、-component-注解" aria-label="Permalink to &quot;1、@Component 注解&quot;">​</a></h3><ul><li>以及 @Configuration，@Controller，@Remoting，@ProxyComponent 都是注解在类上的</li><li>告诉 Solon，当前是个托管组件</li><li>可以申明自己是不是单例</li><li>通过类路径扫描自动检测并注入到容器中</li><li>可以 @Inject 东西</li><li>可以自动装配自己</li></ul><p>其中 @Controller，@Remoting 类的函数会重新包装成 MethodWarp，支持代理效果。</p><p>其中 @ProxyComponent 有 ASM 或 APT 为其生成代理类，支持代理效果。</p><h3 id="_2、-bean-注解" tabindex="-1">2、@Bean 注解 <a class="header-anchor" href="#_2、-bean-注解" aria-label="Permalink to &quot;2、@Bean 注解&quot;">​</a></h3><ul><li>不能注释在类上</li><li>只能用于在 @Configuration 类的函数上，中显式声明单个 Bean。</li><li>意思就是，我要获取这个Bean的时候，框架要按照这种方式去获取这个Bean</li><li>只是单例</li><li><mark>不可以 @Inject 东西</mark></li><li>要手动装配</li></ul><p>在应用开发的过程中，如果想要将“第三方库”中的组件装配到应用容器中，是没有办法在它的类上添加 @Component 、@Inject 注解的，因此就不能使用自动化装配的方案了。</p><p>如果“第三方库”中的组件有 @Component 注解，但没有扫描到。可以使用 @Import 注解进行导入。</p>',9),l=[i];function r(p,m,s,_,c,d){return o(),e("div",null,l)}const C=n(t,[["render",r]]);export{u as __pageData,C as default};
