import{_ as t,v as d,b as o,R as r}from"./chunks/framework.caa0fbaf.js";const f=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"markdown/学习/Solon 开发之常用注解/article-son/@Controller 与 @Remoting 的区别.md","filePath":"markdown/学习/Solon 开发之常用注解/article-son/@Controller 与 @Remoting 的区别.md"}'),e={name:"markdown/学习/Solon 开发之常用注解/article-son/@Controller 与 @Remoting 的区别.md"},n=r("<p>这两组件最终都会把函数转为 Action 并注册到路由器执行。主要区别有：</p><table><thead><tr><th>@Controller</th><th>@Remoting</th><th>说明</th></tr></thead><tbody><tr><td>作为Web开发的控制器</td><td>作为Rpc开发的控制器（或服务端）</td><td></td></tr><tr><td>/</td><td>一般会做为某接口的远程实现</td><td></td></tr><tr><td>/</td><td>一般用 @NamiClient 做它的客户端使用</td><td>假装 Solon 和 Nami 是情侣关系</td></tr><tr><td>函数需要 @Mapping</td><td>函数不要需要 @Mapping</td><td></td></tr><tr><td>/</td><td>函数不可同名（切记）</td><td></td></tr><tr><td>输出普通Json</td><td>输出带@Type的Json（或指定序列化格式）</td><td>两者都可指定序列化格式</td></tr></tbody></table>",2),a=[n];function s(i,l,_,c,m,p){return d(),o("div",null,a)}const g=t(e,[["render",s]]);export{f as __pageData,g as default};
